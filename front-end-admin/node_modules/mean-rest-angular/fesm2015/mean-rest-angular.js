import { throwError } from 'rxjs';
import { catchError, map } from 'rxjs/operators';
import { HttpHeaders, HttpParams } from '@angular/common/http';
import { NG_VALIDATORS } from '@angular/forms';
import { Injectable, EventEmitter, Input, Directive, ElementRef, Renderer2, NgModule } from '@angular/core';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var modalHtml = `
<div class="meanExpressAngularModal" id="meanExpressAngularModal">
  <div class="meanExpressAngularModal-content">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="meanExpressAngularModalTitle">Modal title from function</h5>
        <button type="button" class="close" id="meanExpressAngularModalClose" aria-label="Close" >
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body" id="meanExpressAngularModalBody">
        Hello
      </div>
      <div class="modal-footer" id="meanExpressAngularModalFooter">
      </div>
    </div>
  </div>
</div> 
`;
/** @type {?} */
var modalCss = `
.meanExpressAngularModal {
    display: none; 
    position: fixed; 
    z-index: 100; 
    padding-top: 100px; 
    left: 0;
    top: 0;
    width: 100%;
    height: 100%; 
    overflow: auto; 
    background-color: rgb(0,0,0);
    background-color: rgba(0,0,0,0.4);
}

.meanExpressAngularModal.show {
    display: block; 
}

.meanExpressAngularModal-content {
    position: relative;
    background-color: #fefefe;
    margin: auto;
    padding: 0;
    border: 1px solid #888;
    width: 50%;
    box-shadow: 0 4px 8px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);
    -webkit-animation-name: modalanimatetop;
    -webkit-animation-duration: 0.4s;
    animation-name: modalanimatetop;
    animation-duration: 0.4s
}

@-webkit-keyframes modalanimatetop {
    from {top:-300px; opacity:0} 
    to {top:0; opacity:1}
}

@keyframes modalanimatetop {
    from {top:-300px; opacity:0}
    to {top:0; opacity:1}
}
`;
class ModalConfig {
}
class Modal {
    /**
     * @param {?} config
     */
    constructor(config) {
        this.config = config;
    }
    /**
     * @return {?}
     */
    show() {
        /** @type {?} */
        var config = this.config;
        if (!$('#meanExpressAngularModal').length) {
            $("<style type='text/css' id='meanExpressAngularModalCss'>" + modalCss + "</style>").appendTo("head");
            $('body').append(modalHtml);
        }
        $("#meanExpressAngularModalFooter").empty();
        for (var i = 0; i < config.buttons.length; i++) {
            /** @type {?} */
            var text = config.buttons[i];
            /** @type {?} */
            var button = '<button type="button" class="btn btn-primary" id="meanExpressAngularModalBtn' + i + '" >' + text + '</button>';
            $("#meanExpressAngularModalFooter").append(button);
            $("#meanExpressAngularModalBtn" + i).click(function (event) {
                $('#meanExpressAngularModal').removeClass("show");
                /** @type {?} */
                var index = parseInt(event.target.id.replace("meanExpressAngularModalBtn", ""));
                config.callBack(config.returns[index]);
            });
        }
        $("#meanExpressAngularModalTitle").empty();
        $("#meanExpressAngularModalTitle").append(config.title);
        $("#meanExpressAngularModalBody").empty();
        $("#meanExpressAngularModalBody").append(config.content);
        $("#meanExpressAngularModalClose").click(function () {
            $('#meanExpressAngularModal').removeClass("show");
            config.callBack(false);
        });
        $('#meanExpressAngularModal').addClass("show");
    }
    /**
     * @return {?}
     */
    hide() {
        $('#meanExpressAngularModal').removeClass("show");
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var snackBarCss = `
.meanExpressAngularSnackBar {
    visibility: hidden;
    min-width: 250px;
    margin-left: -125px;
    background-color: #333;
    color: #fff;
    text-align: center; 
    border-radius: 2px; 
    padding: 16px; 
    position: fixed;
    z-index: 1;
    left: 50%;
    bottom: 30px;
}

.meanExpressAngularSnackBar.show {
    visibility: visible;

    -webkit-animation: snackbarfadein 0.5s, snackbarfadeout 0.5s 2.5s;
    animation: snackbarfadein 0.5s, snackbarfadeout 0.5s 2.5s;
}

@-webkit-keyframes snackbarfadein {
    from {bottom: 0; opacity: 0;} 
    to {bottom: 30px; opacity: 1;}
}

@keyframes snackbarfadein {
    from {bottom: 0; opacity: 0;}
    to {bottom: 30px; opacity: 1;}
}

@-webkit-keyframes snackbarfadeout {
    from {bottom: 30px; opacity: 1;} 
    to {bottom: 0; opacity: 0;}
}

@keyframes snackbarfadeout {
    from {bottom: 30px; opacity: 1;}
    to {bottom: 0; opacity: 0;}
}
`;
class SnackBarConfig {
}
class SnackBar {
    /**
     * @param {?} config
     */
    constructor(config) {
        this.config = config;
    }
    /**
     * @private
     * @return {?}
     */
    getHtml() {
        /** @type {?} */
        var id = 'meanExpressAngularSnackBar' + Date.now();
        /** @type {?} */
        var snackBarHtml = `
<div class="meanExpressAngularSnackBar" id="` + id + `">

</div>
`;
        return { id: id, html: snackBarHtml };
    }
    /**
     * @return {?}
     */
    show() {
        if (!$('#meanExpressAngularSnackBarCss').length) {
            $("<style type='text/css' id='meanExpressAngularSnackBarCss'>" + snackBarCss + "</style>").appendTo("head");
        }
        /** @type {?} */
        var html = this.getHtml();
        /** @type {?} */
        var selector = '#' + html.id;
        $('body').append(html.html);
        $(selector).append(this.config.content);
        $(selector).addClass("show");
        setTimeout(function () {
            $(selector).removeClass("show");
            setTimeout(function () { $(selector).remove(); }, 500);
        }, 3000);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var errorCss = `
.meanExpressAngularError {
    visibility: hidden; 
    box-shadow: 0 4px 8px 0 rgba(0,0,0,0.2), 0 6px 20px 0 rgba(0,0,0,0.19);
    min-width: 250px; 
    max-width: 60%;
    left: 50%;
    top: 20%;
    transform: translate(-50%, 0);
    position: fixed; 
    z-index: 10; 
}
.meanExpressAngularError.show {
    visibility: visible; 
}

.meanExpressAngularErrorMoreLink {
    display: none;
}
.meanExpressAngularErrorMoreLink.show {
    display: block;
}
.meanExpressAngularErrorMore {
    display: none;
    font-size: 0.75rem;
    font-color: black;
    background-color: gray;
}
.meanExpressAngularErrorMore.show {
    display: block;
}
`;
class ErrorToastConfig {
}
class ErrorToast {
    /**
     * @param {?} config
     */
    constructor(config) {
        this.config = config;
    }
    /**
     * @private
     * @return {?}
     */
    getHtml() {
        /** @type {?} */
        var id = 'meanExpressAngularError' + Date.now();
        /** @type {?} */
        var errorHtml = `
<div class="alert alert-danger fade in alert-dismissible meanExpressAngularError"
    id="` + id + `">
 <button type="button" class="close" aria-label="Close" id="button` + id + `">
    <span aria-hidden="true" style="font-size:20px">Ã—</span>
  </button>
  <div>
    <strong>Error!</strong>
  </div>
  <div id="content` + id + `">
  </div>
  <a id="link` + id + `" class="meanExpressAngularErrorMoreLink" href="." >Show more details...
  </a>
  <div id="more` + id + `" class="meanExpressAngularErrorMore">
  </div>
</div>
`;
        return { id: id, html: errorHtml };
    }
    /**
     * @return {?}
     */
    show() {
        if (!$('#meanExpressAngularErrorCss').length) {
            $("<style type='text/css' id='meanExpressAngularErrorCss'>" + errorCss + "</style>").appendTo("head");
        }
        /** @type {?} */
        var html = this.getHtml();
        /** @type {?} */
        var selector = '#' + html.id;
        /** @type {?} */
        var contentSelector = '#content' + html.id;
        /** @type {?} */
        var moreSelector = '#more' + html.id;
        /** @type {?} */
        var linkSelector = '#link' + html.id;
        /** @type {?} */
        var buttonSelector = '#button' + html.id;
        $('body').append(html.html);
        $(contentSelector).append(this.config.content);
        if (this.config.more) {
            $(moreSelector).append(this.config.more);
            $(linkSelector).addClass("show");
            $(linkSelector).click(function (event) {
                event.preventDefault();
                $(moreSelector).addClass("show");
            });
        }
        $(buttonSelector).click(function (event) { $(selector).removeClass("show"); });
        $(selector).addClass("show");
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ServiceError {
}
class BaseService {
    /**
     * @param {?} http
     * @param {?} serviceUrl
     */
    constructor(http, serviceUrl) {
        this.http = http;
        this.serviceUrl = serviceUrl;
        this.storage = {};
    }
    /**
     * @param {?} name
     * @return {?}
     */
    getFromStorage(name) {
        return this.storage[name];
    }
    /**
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    putToStorage(name, value) {
        this.storage[name] = value;
    }
    /**
     * @protected
     * @param {?} error
     * @return {?}
     */
    errorResponseHandler(error) {
        /** @type {?} */
        let err = new ServiceError();
        if (error.error instanceof ErrorEvent) {
            // A client-side or network error occurred. Handle it accordingly.
            err.status = 0;
            err.clientErrorMsg = error.error.message;
        }
        else {
            // The backend returned an unsuccessful response code.
            // The response body may contain clues as to what went wrong,
            err.status = error.status;
            err.serverError = error.error;
        }
        // return an observable with a user-facing error message
        return throwError(err);
    }
    /**
     * @protected
     * @param {?} detail
     * @return {?}
     */
    formatDetail(detail) {
        return detail;
    }
    /**
     * @protected
     * @param {?} list
     * @return {?}
     */
    formatList(list) {
        return list;
    }
    /**
     * @param {?} page
     * @param {?} per_page
     * @param {?} searchContext
     * @return {?}
     */
    getList(page, per_page, searchContext) {
        /** @type {?} */
        let httpOptions = {
            params: new HttpParams().set('__page', page.toString())
                .set('__per_page', per_page.toString()),
            headers: new HttpHeaders({ 'Accept': 'application/json' }),
        };
        if (!searchContext) {
            return this.http.get(this.serviceUrl, httpOptions)
                .pipe(map(this.formatList), catchError(this.errorResponseHandler));
        }
        httpOptions.params = httpOptions.params.set('action', "Search");
        return this.http.post(this.serviceUrl + "mddsaction/get", searchContext, httpOptions)
            .pipe(catchError(this.errorResponseHandler));
    }
    /**
     * @param {?} page
     * @param {?} per_page
     * @return {?}
     */
    getListWithCondition(page, per_page) {
        /** @type {?} */
        let httpOptions = {
            params: new HttpParams().set('__page', page.toString())
                .set('__per_page', per_page.toString()),
            headers: new HttpHeaders({ 'Accept': 'application/json' }),
        };
        return this.http.get(this.serviceUrl, httpOptions)
            .pipe(map(this.formatList), catchError(this.errorResponseHandler));
    }
    /**
     * @param {?} id
     * @param {?} action
     * @return {?}
     */
    getDetailForAction(id, action) {
        /** @type {?} */
        let httpOptions = {
            headers: new HttpHeaders({ 'Accept': 'application/json' }),
        };
        /** @type {?} */
        let serviceUrl = this.serviceUrl;
        if (action) {
            httpOptions['params'] = new HttpParams().set('action', action);
            if (action == "edit")
                action = "post";
            serviceUrl = serviceUrl + "mddsaction/" + action + "/";
        }
        return this.http.get(serviceUrl + id, httpOptions)
            .pipe(map(this.formatDetail), catchError(this.errorResponseHandler));
    }
    /**
     * @param {?} id
     * @return {?}
     */
    getDetail(id) {
        return this.getDetailForAction(id, null);
    }
    /**
     * @param {?} id
     * @return {?}
     */
    deleteOne(id) {
        return this.http.delete(this.serviceUrl + id)
            .pipe(catchError(this.errorResponseHandler));
    }
    /**
     * @param {?} ids
     * @return {?}
     */
    deleteManyByIds(ids) {
        /** @type {?} */
        let httpOptions = {
            headers: new HttpHeaders({ 'Content-Type': 'application/json' }),
            params: new HttpParams().set('action', "DeleteManyByIds"),
        };
        return this.http.post(this.serviceUrl + "mddsaction/delete", ids, httpOptions)
            .pipe(catchError(this.errorResponseHandler));
    }
    /**
     * @param {?} item
     * @return {?}
     */
    createOne(item) {
        /** @type {?} */
        let httpOptions = {
            headers: new HttpHeaders({ 'Content-Type': 'application/json' })
        };
        return this.http.put(this.serviceUrl, item, httpOptions)
            .pipe(map(this.formatDetail), catchError(this.errorResponseHandler));
    }
    /**
     * @param {?} id
     * @param {?} item
     * @return {?}
     */
    updateOne(id, item) {
        /** @type {?} */
        let httpOptions = {
            headers: new HttpHeaders({ 'Content-Type': 'application/json' })
        };
        return this.http.post(this.serviceUrl + id, item, httpOptions)
            .pipe(catchError(this.errorResponseHandler));
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MraCommonService {
    constructor() {
        this.storage = {};
    }
    /**
     * @param {?} name
     * @return {?}
     */
    getFromStorage(name) {
        return this.storage[name];
    }
    /**
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    putToStorage(name, value) {
        this.storage[name] = value;
    }
}
MraCommonService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
MraCommonService.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class Util {
    /**
     * @param {?} obj
     * @return {?}
     */
    static clone(obj) {
        /** @type {?} */
        let copy;
        // Handle the 3 simple types, and null or undefined
        if (null == obj || "object" != typeof obj)
            return obj;
        // Handle Date
        if (obj instanceof Date) {
            copy = new Date();
            copy.setTime(obj.getTime());
            return copy;
        }
        // Handle Array
        if (obj instanceof Array) {
            copy = [];
            for (var i = 0, len = obj.length; i < len; i++) {
                copy[i] = Util.clone(obj[i]);
            }
            return copy;
        }
        // Handle Object
        if (obj instanceof Object) {
            copy = {};
            for (var attr in obj) {
                if (obj.hasOwnProperty(attr))
                    copy[attr] = Util.clone(obj[attr]);
            }
            return copy;
        }
        throw new Error("Unable to copy obj! Its type isn't supported.");
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
const ViewType = {
    LIST: 0,
    DETAIL: 1,
    EDIT: 2,
};
ViewType[ViewType.LIST] = 'LIST';
ViewType[ViewType.DETAIL] = 'DETAIL';
ViewType[ViewType.EDIT] = 'EDIT';
class BaseComponent {
    /**
     * @param {?} service
     * @param {?} injector
     * @param {?} router
     * @param {?} route
     * @param {?} location
     * @param {?} view
     * @param {?} itemCamelName
     */
    constructor(service, injector, router, route, location, view, itemCamelName) {
        this.service = service;
        this.injector = injector;
        this.router = router;
        this.route = route;
        this.location = location;
        this.view = view;
        this.itemCamelName = itemCamelName;
        this.objectKeys = Object.keys;
        this.storage = {};
        //For list and pagination
        this.list = [];
        this.majorUi = true;
        this.eventEmitter = new EventEmitter();
        this.page = 1;
        this.per_page = 25;
        this.total_count = 0;
        this.total_pages = 0;
        this.pages = [];
        this.left_more = false;
        this.right_more = false;
        this.checkAll = false;
        //used to mark deleted items, or items that will show sub-detail, etc.
        this.checkedItem = [];
        //For edit and view details
        this.detail = {};
        this._detail = {}; //a clone and used to send/receive from next work
        //a clone and used to send/receive from next work
        this._extra = {}; //extra info.
        this.subEdit = false; //a edit-sub component
        //a edit-sub component
        //for fields with enum values
        this.enums = {};
        this.stringFields = [];
        this.referenceFields = [];
        this.referenceFieldsMap = {};
        this.dateFields = [];
        this.indexFields = [];
        this.multiSelectionFields = [];
        this.arrayFields = []; //element is [fieldName, elementType]
        //element is [fieldName, elementType]
        this.mapFields = []; //element is [fieldName, elementType, mapKey]
        //element is [fieldName, elementType, mapKey]
        this.dateFormat = "MM/DD/YYYY";
        this.timeFormat = "hh:mm:ss";
        this.hiddenFields = []; //fields hide from view. Currrently used by "Add" view of edit-sub
        this.refreshing = false;
        this.clickedId = null;
        this.selectedId = null;
        this.moreSearchOpened = false;
        //type of QueryList<T>
        this.textEditorMap = {};
        /**
         * Any View - add new component in the current view
         */
        this.isAdding = false;
        this.ItemCamelName = itemCamelName.charAt(0).toUpperCase() + itemCamelName.substr(1);
        this.itemName = itemCamelName.toLowerCase();
        this.parentItem = this.getParentRouteItem();
        this.commonService = injector.get(MraCommonService);
    }
    /**
     * @protected
     * @param {?} error
     * @return {?}
     */
    onServiceError(error) {
        //clear any pending flags
        this.refreshing = false;
        /** @type {?} */
        let errMsg;
        /** @type {?} */
        let more;
        if (error.clientErrorMsg) {
            errMsg = error.clientErrorMsg;
        }
        else if (error.serverError) {
            if (error.status == 401)
                return; //Don't show unauthorized error
            if (typeof error.serverError === 'object') {
                errMsg = error.status + ": " + JSON.stringify(error.serverError);
            }
            else {
                errMsg = error.status + ": " + error.serverError;
            }
        }
        console.info("Error: " + errMsg);
        if (!errMsg)
            errMsg = "Unknown error.";
        if (errMsg.length > 80) {
            more = errMsg;
            errMsg = errMsg.substring(0, 80) + "...";
        }
        /** @type {?} */
        let errorToastConfig = {
            content: errMsg,
            more: more
        };
        /** @type {?} */
        let errorToast = new ErrorToast(errorToastConfig);
        errorToast.show();
    }
    /**
     * @protected
     * @return {?}
     */
    populatePages() {
        this.pages = [];
        /** @type {?} */
        const SHOW_PAGE = 9;
        /** @type {?} */
        const HALF = (SHOW_PAGE - 1) / 2;
        /** @type {?} */
        let min;
        /** @type {?} */
        let max;
        if (this.total_pages <= SHOW_PAGE) {
            min = 1;
            max = this.total_pages;
            this.left_more = false;
            this.right_more = false;
        }
        else {
            if (this.page - 1 < HALF) {
                min = 1;
                max = SHOW_PAGE - 1;
                this.left_more = false;
                this.right_more = true;
            }
            else if (this.total_pages - this.page < HALF) {
                max = this.total_pages;
                min = (this.total_pages - SHOW_PAGE + 1) + 1;
                this.left_more = true;
                this.right_more = false;
            }
            else {
                min = this.page - HALF + 1;
                max = this.page + HALF - 1;
                this.left_more = true;
                this.right_more = true;
            }
        }
        for (let i = min; i <= max; i++) {
            this.pages.push(i);
        }
    }
    /**
     * @private
     * @param {?} key
     * @return {?}
     */
    getKey(key) {
        /** @type {?} */
        let url = this.router.url.split(';')[0].split('?')[0];
        return url + ":" + key;
    }
    /**
     * @private
     * @param {?} key
     * @param {?} value
     * @return {?}
     */
    putToStorage(key, value) {
        if (this.majorUi) {
            //only major UI we want to cache and recover when user comes back
            this.commonService.putToStorage(this.getKey(key), value);
        }
        else {
            this.storage[key] = value;
        }
    }
    /**
     * @private
     * @param {?} key
     * @return {?}
     */
    getFromStorage(key) {
        if (this.majorUi) {
            return this.commonService.getFromStorage(this.getKey(key));
        }
        else {
            return this.storage[key];
        }
    }
    /**
     * @private
     * @param {?} page
     * @return {?}
     */
    routeToPage(page) {
        this.putToStorage("page", page);
        this.populateList();
    }
    /**
     * @protected
     * @return {?}
     */
    onNextPage() {
        if (this.page >= this.total_pages)
            return;
        this.routeToPage(this.page + 1);
    }
    /**
     * @protected
     * @return {?}
     */
    onPreviousPage() {
        if (this.page <= 1)
            return;
        this.routeToPage(this.page - 1);
    }
    /**
     * @protected
     * @param {?} p
     * @return {?}
     */
    onGotoPage(p) {
        if (p > this.total_pages || p < 1)
            return;
        this.routeToPage(p);
    }
    /**
     * @protected
     * @return {?}
     */
    goBack() {
        this.location.back();
        /*
        // window.history.back();
        if (this.view != ViewType.EDIT)
            this.location.back();
        else {
            let url = this.location.path(); //in EDIT view, the current url is skipped. So get the "previous" one from path.
            this.router.navigateByUrl(url);
        }
        */
    }
    /**
     * @protected
     * @param {?} detail
     * @return {?}
     */
    stringify(detail) {
        /** @type {?} */
        let str = "";
        for (let fnm of this.indexFields) {
            if (detail[fnm] && typeof detail[fnm] != 'object')
                str += " " + detail[fnm];
        }
        if (!str) {
            for (let prop in detail) {
                if (prop !== '_id' && detail[prop] && typeof detail[prop] != 'object') {
                    str += " " + detail[prop];
                }
            }
        }
        if (!str)
            str = detail["_id"] ? detail["_id"] : "...";
        str = str.replace(/^\s+|\s+$/g, '');
        if (str.length > 30)
            str = str.substr(0, 27) + '...';
        return str;
    }
    /**
     * Start: handle reference fields**
     * @protected
     * @param {?} field
     * @param {?} fieldName
     * @return {?}
     */
    formatReferenceField(field, fieldName) {
        /** @type {?} */
        let id;
        /** @type {?} */
        let value;
        if (typeof field == 'string') {
            //assume this is the "_id", let see we have the cached details for this ref from service
            /** @type {?} */
            let refDetail = this.commonService.getFromStorage(field);
            if (refDetail && (typeof refDetail == 'object'))
                field = refDetail;
            else {
                id = field;
                field = { '_id': id };
            }
        }
        else if (field && (typeof field == 'object')) {
            id = field['_id'];
            /** @type {?} */
            let referIndex = '';
            for (let k in field) {
                if (k != '_id')
                    referIndex += " " + field[k];
            }
            referIndex = referIndex.replace(/^\s+|\s+$/g, '');
            if (referIndex.length >= 20)
                referIndex = referIndex.substring(0, 20) + "...";
            field = { '_id': id, 'value': referIndex ? referIndex : fieldName };
        }
        else { //not defined
            field = { '_id': id, 'value': value };
        }
        return field;
    }
    /**
     * @protected
     * @param {?} detail
     * @return {?}
     */
    formatReference(detail) {
        for (let fnm of this.referenceFields) {
            detail[fnm] = this.formatReferenceField(detail[fnm], fnm);
        }
        return detail;
    }
    /**
     * @protected
     * @param {?} detail
     * @return {?}
     */
    deFormatReference(detail) {
        for (let fnm of this.referenceFields) {
            if (typeof detail[fnm] !== 'object') { //not defined
                //let date values undefined
                delete detail[fnm];
            }
            else {
                /** @type {?} */
                let id = detail[fnm]['_id'];
                if (typeof id !== 'string')
                    delete detail[fnm];
                else
                    detail[fnm] = id;
            }
        }
        return detail;
    }
    /**
     * @protected
     * @param {?} field
     * @return {?}
     */
    clearFieldReference(field) {
        for (let prop in field) {
            field[prop] = undefined;
        }
        return field;
    }
    /**
     * @protected
     * @param {?} field
     * @return {?}
     */
    isDefinedFieldReference(field) {
        if ('_id' in field && typeof field['_id'] == 'string')
            return true;
        return false;
    }
    /**
     * Start: handle date fields**
     * @protected
     * @param {?} field
     * @return {?}
     */
    formatDateField(field) {
        /** @type {?} */
        let fmt = this.dateFormat;
        /** @type {?} */
        let t_fmt = this.timeFormat;
        /** @type {?} */
        let d;
        /** @type {?} */
        let M;
        /** @type {?} */
        let yyyy;
        /** @type {?} */
        let h;
        /** @type {?} */
        let m;
        /** @type {?} */
        let s;
        /** @type {?} */
        let dt = new Date(field);
        /** @type {?} */
        let dd;
        /** @type {?} */
        let MM;
        /** @type {?} */
        let hh;
        /** @type {?} */
        let mm;
        /** @type {?} */
        let ss;
        d = dt.getDate();
        M = dt.getMonth() + 1;
        yyyy = dt.getFullYear();
        /** @type {?} */
        let yy = yyyy.toString().slice(2);
        h = dt.getHours();
        m = dt.getMinutes();
        s = dt.getSeconds();
        dd = d < 10 ? '0' + d : d.toString();
        MM = M < 10 ? '0' + M : M.toString();
        hh = h < 10 ? '0' + h : h.toString();
        mm = m < 10 ? '0' + m : m.toString();
        ss = s < 10 ? '0' + s : s.toString();
        /** @type {?} */
        let value = fmt.replace(/yyyy/ig, yyyy.toString()).
            replace(/yy/ig, yy.toString()).
            replace(/MM/g, MM.toString()).
            replace(/dd/ig, dd.toString());
        /** @type {?} */
        let t_value = t_fmt.replace(/hh/ig, hh.toString()).
            replace(/mm/g, mm.toString()).
            replace(/ss/ig, ss.toString());
        /*Datepicker uses NgbDateStruct as a model and not the native Date object.
        It's a simple data structure with 3 fields. Also note that months start with 1 (as in ISO 8601).
        
        we add h, m, s here
        */
        //"from" and "to" used for search context. pop: show the selection popup
        return { 'date': { day: d, month: M, year: yyyy }, 'value': value, 'from': undefined, 'to': undefined, 'pop': false,
            'time': { hour: h, minute: m, second: s }, 't_value': value, 't_from': undefined, 't_to': undefined, 't_pop': false };
    }
    /**
     * @protected
     * @param {?} detail
     * @return {?}
     */
    formatDate(detail) {
        for (let fnm of this.dateFields) {
            if (typeof detail[fnm] !== 'string') { //not defined
                //important: let date values undefined. "from" and "to" used for search context. pop: show the selection popup
                detail[fnm] = { 'date': undefined, 'value': undefined, 'from': undefined, 'to': undefined, 'pop': false };
            }
            else {
                detail[fnm] = this.formatDateField(detail[fnm]);
            }
        }
        return detail;
    }
    /**
     * @protected
     * @param {?} date
     * @return {?}
     */
    deFormatDateField(date) {
        /** @type {?} */
        let d;
        /** @type {?} */
        let M;
        /** @type {?} */
        let yyyy;
        yyyy = date.year;
        M = date.month - 1;
        d = date.day;
        if (typeof yyyy !== 'number' || typeof M !== 'number' || typeof d !== 'number')
            return null;
        else {
            /** @type {?} */
            let dt = new Date(yyyy, M, d, 0, 0, 0, 0);
            return dt.toISOString();
        }
    }
    /**
     * @protected
     * @param {?} detail
     * @return {?}
     */
    deFormatDate(detail) {
        for (let fnm of this.dateFields) {
            if (typeof detail[fnm] !== 'object') { //not defined
                //let date values undefined
                delete detail[fnm];
            }
            else {
                if (!detail[fnm].date)
                    delete detail[fnm];
                else {
                    /** @type {?} */
                    let dateStr = this.deFormatDateField(detail[fnm].date);
                    if (!dateStr)
                        delete detail[fnm];
                    else
                        detail[fnm] = dateStr;
                }
            }
        }
        return detail;
    }
    /**
     * @protected
     * @param {?} field
     * @return {?}
     */
    clearFieldDate(field) {
        for (let prop in field) {
            field[prop] = undefined;
        }
        return field;
    }
    /**
     * @protected
     * @param {?} field
     * @return {?}
     */
    isDefinedFieldDate(field) {
        if (typeof field === 'object') {
            if (typeof field['date'] == 'object')
                return true;
            if (typeof field['from'] == 'object')
                return true;
            if (typeof field['to'] == 'object')
                return true;
        }
        return false;
    }
    /**
     * Start: handle array of multi-selection fields**
     * @protected
     * @param {?} field
     * @param {?} enums
     * @return {?}
     */
    formatArrayMultiSelectionField(field, enums) {
        /** @type {?} */
        let selectObj = {};
        /** @type {?} */
        let value = "";
        for (let e of enums) {
            selectObj[e] = false; //not exist
        }
        if (Array.isArray(field)) { //not defined
            for (let e of field) {
                selectObj[e] = true; //exist.
            }
            value = field.join(" | ");
        }
        return { 'selection': selectObj, value: value };
    }
    /**
     * @protected
     * @param {?} detail
     * @return {?}
     */
    formatArrayMultiSelection(detail) {
        for (let fnm of this.multiSelectionFields) {
            detail[fnm] = this.formatArrayMultiSelectionField(detail[fnm], this.enums[fnm]);
        }
        return detail;
    }
    /**
     * @protected
     * @param {?} detail
     * @return {?}
     */
    deFormatArrayMultiSelection(detail) {
        for (let fnm of this.multiSelectionFields) {
            if (typeof detail[fnm] !== 'object') { //not defined
                delete detail[fnm];
            }
            else {
                if (!detail[fnm].selection)
                    delete detail[fnm];
                else {
                    /** @type {?} */
                    let selectArray = [];
                    for (let e of this.enums[fnm]) {
                        if (detail[fnm].selection[e])
                            selectArray.push(e);
                    }
                    if (selectArray.length > 0)
                        detail[fnm] = selectArray;
                    else
                        delete detail[fnm];
                }
            }
        }
        return detail;
    }
    /**
     * @protected
     * @param {?} field
     * @return {?}
     */
    clearFieldArrayMultiSelection(field) {
        if (!field['selection'])
            return field;
        for (let prop in field['selection']) {
            field['selection'][prop] = false; //not exist
        }
        return field;
    }
    /**
     * @protected
     * @param {?} field
     * @return {?}
     */
    isDefinedFieldArrayMultiSelection(field) {
        if ('selection' in field && typeof field['selection'] == 'object') {
            /** @type {?} */
            let keys = Object.keys(field['selection']);
            return keys.some(e => { return field['selection'][e]; });
        }
        return false;
    }
    /**
     * @protected
     * @param {?} fieldName
     * @return {?}
     */
    multiselectionSelected(fieldName) {
        if (!this.detail[fieldName] || typeof this.detail[fieldName]['selection'] != 'object') {
            return false;
        }
        return this.isDefinedFieldArrayMultiSelection(this.detail[fieldName]);
    }
    /***End: handle array of multi-selection fields***/
    /**
     * Start: handle map fields**
     * @protected
     * @param {?} field
     * @param {?} elementType
     * @return {?}
     */
    formatMapField(field, elementType) {
        /** @type {?} */
        let selectObj = {};
        /** @type {?} */
        let values = [];
        if (typeof field == 'object') {
            selectObj = field;
            for (let e in field) {
                if (elementType === 'SchemaString') {
                    values.push(e + "(" + field[e] + ")");
                }
            }
        }
        values = values.filter(x => !!x);
        /** @type {?} */
        let value = values.join(" | ");
        return { 'selection': selectObj, value: value, keys: [] };
    }
    /**
     * @protected
     * @param {?} detail
     * @return {?}
     */
    formatMapFields(detail) {
        for (let f of this.mapFields) {
            //[fieldName, elementType]
            detail[f[0]] = this.formatMapField(detail[f[0]], f[1]);
        }
        return detail;
    }
    /**
     * @protected
     * @param {?} detail
     * @return {?}
     */
    deFormatMapFields(detail) {
        for (let f of this.mapFields) {
            //[fieldName, elementType]
            /** @type {?} */
            let fnm = f[0];
            /** @type {?} */
            let elementType = f[1];
            if (typeof detail[fnm] !== 'object') { //not defined
                delete detail[fnm];
            }
            else {
                if (!detail[fnm].selection)
                    delete detail[fnm];
                else {
                    /** @type {?} */
                    let selectMap = detail[fnm].selection;
                    for (let e in detail[fnm].selection) {
                    }
                    if (Object.keys(selectMap).length > 0)
                        detail[fnm] = selectMap;
                    else
                        delete detail[fnm];
                }
            }
        }
        return detail;
    }
    /**
     * @protected
     * @param {?} field
     * @return {?}
     */
    clearFieldMap(field) {
        if (!field['selection'])
            return field;
        field['selection'] = {};
        field.value = undefined;
        return field;
    }
    /**
     * @protected
     * @param {?} field
     * @return {?}
     */
    isDefinedFieldMap(field) {
        if ('selection' in field && typeof field['selection'] == 'object') {
            return Object.keys(field['selection']).length > 0;
        }
        return false;
    }
    /**
     * @protected
     * @param {?} fieldName
     * @return {?}
     */
    mapSelected(fieldName) {
        if (!this.detail[fieldName] || typeof this.detail[fieldName]['selection'] != 'object') {
            return false;
        }
        return this.isDefinedFieldMap(this.detail[fieldName]);
    }
    /***End: handle map fields***/
    /**
     * Start: handle array fields**
     * @protected
     * @param {?} field
     * @param {?} elementType
     * @return {?}
     */
    formatArrayField(field, elementType) {
        /** @type {?} */
        let selectArray = [];
        /** @type {?} */
        let values = [];
        if (Array.isArray(field)) { //not defined
            for (let e of field) {
                if (elementType === 'ObjectId') {
                    /** @type {?} */
                    let ref = this.formatReferenceField(e, "...");
                    selectArray.push(ref);
                    values.push(ref.value);
                }
                else if (elementType === 'SchemaString') {
                    selectArray.push(e);
                    values.push(e);
                }
            }
        }
        values = values.filter(x => !!x);
        /** @type {?} */
        let value = values.join(" | ");
        return { 'selection': selectArray, value: value };
    }
    /**
     * @protected
     * @param {?} detail
     * @return {?}
     */
    formatArrayFields(detail) {
        for (let f of this.arrayFields) {
            //[fieldName, elementType]
            detail[f[0]] = this.formatArrayField(detail[f[0]], f[1]);
        }
        return detail;
    }
    /**
     * @protected
     * @param {?} detail
     * @return {?}
     */
    deFormatArrayFields(detail) {
        for (let f of this.arrayFields) {
            //[fieldName, elementType]
            /** @type {?} */
            let fnm = f[0];
            /** @type {?} */
            let elementType = f[1];
            if (typeof detail[fnm] !== 'object') { //not defined
                delete detail[fnm];
            }
            else {
                if (!detail[fnm].selection)
                    delete detail[fnm];
                else {
                    /** @type {?} */
                    let selectArray = [];
                    for (let e of detail[fnm].selection) {
                        if (elementType === 'ObjectId') {
                            if (e && e['_id'] && typeof e['_id'] === 'string')
                                selectArray.push(e['_id']);
                        }
                        else if (elementType === 'SchemaString') {
                            if (e)
                                selectArray.push(e);
                        }
                    }
                    if (selectArray.length > 0)
                        detail[fnm] = selectArray;
                    else
                        delete detail[fnm];
                }
            }
        }
        return detail;
    }
    /**
     * @protected
     * @param {?} field
     * @return {?}
     */
    clearFieldArray(field) {
        if (!field['selection'])
            return field;
        field['selection'] = [];
        field.value = undefined;
        return field;
    }
    /**
     * @protected
     * @param {?} field
     * @return {?}
     */
    isDefinedFieldArray(field) {
        if ('selection' in field && Array.isArray(field['selection'])) {
            return field['selection'].length > 0;
        }
        return false;
    }
    /**
     * @protected
     * @param {?} fieldName
     * @return {?}
     */
    arraySelected(fieldName) {
        if (!this.detail[fieldName] || !Array.isArray(this.detail[fieldName]['selection'])) {
            return false;
        }
        return this.isDefinedFieldArray(this.detail[fieldName]);
    }
    /**
     * End: handle array fields**
     * @protected
     * @param {?} detail
     * @return {?}
     */
    formatDetail(detail) {
        detail = this.formatReference(detail);
        detail = this.formatDate(detail);
        detail = this.formatArrayMultiSelection(detail);
        detail = this.formatArrayFields(detail);
        detail = this.formatMapFields(detail);
        return detail;
    }
    /**
     * @protected
     * @param {?} detail
     * @return {?}
     */
    deFormatDetail(detail) {
        /** @type {?} */
        let cpy = Util.clone(detail);
        cpy = this.deFormatReference(cpy);
        cpy = this.deFormatDate(cpy);
        cpy = this.deFormatArrayMultiSelection(cpy);
        cpy = this.deFormatArrayFields(cpy);
        cpy = this.deFormatMapFields(cpy);
        return cpy;
    }
    /**
     * @protected
     * @param {?} id
     * @return {?}
     */
    populateDetail(id) {
        return this.populateDetailForAction(id, null);
    }
    /**
     * @protected
     * @param {?} id
     * @param {?} action
     * @return {?}
     */
    populateDetailForAction(id, action) {
        //action: eg: action=edit  -> get detail for editing purpose 
        this.service.getDetailForAction(id, action).subscribe(detail => {
            /** @type {?} */
            let originalDetail = Util.clone(detail);
            if (detail["_id"])
                this.commonService.putToStorage(detail["_id"], originalDetail); //cache it
            this.detail = this.formatDetail(detail);
            this.extraFieldsUnload(); //unload data to text editors, etc
            if (action == 'edit') {
                this.extraInfoPopulate(); //collect other info required for edit view
            }
            if (this.refreshing) {
                this.refreshing = false;
                /** @type {?} */
                let snackBarConfig = {
                    content: "Detail refreshed"
                };
                /** @type {?} */
                let snackBar = new SnackBar(snackBarConfig);
                snackBar.show();
            }
            this.eventEmitter.emit(this.detail);
        }, this.onServiceError);
        return this.eventEmitter;
    }
    /**
     * @protected
     * @param {?} copy_id
     * @return {?}
     */
    populateDetailFromCopy(copy_id) {
        this.service.getDetail(copy_id).subscribe(detail => {
            this.detail = this.formatDetail(detail);
            delete this.detail["_id"];
            this.extraFieldsUnload(); //unload data to text editors, etc
            this.extraInfoPopulate(); //collect other info required for create view
        }, this.onServiceError);
    }
    /**
     * @protected
     * @return {?}
     */
    extraInfoPopulate() {
        for (let fieldDef of this.mapFields) {
            //fieldDef: [field.fieldName, field.elementType, keyType, keyRefName, keyRefService, keyRefSubField]
            /** @type {?} */
            let fieldName = fieldDef[0];
            //this.<keyRefName>.<keyRefSubField>
            /** @type {?} */
            let mapKeyType = fieldDef[2];
            //this.<keyRefName>.<keyRefSubField>
            /** @type {?} */
            let keyArray = [];
            if (mapKeyType == "ObjectId") {
                /** @type {?} */
                let keyRefName = fieldDef[3];
                /** @type {?} */
                let recordKey = 'key-id-' + keyRefName;
                /** @type {?} */
                let refService = this.injector.get(fieldDef[4]);
                /** @type {?} */
                let id = this.detail[keyRefName] ? this.detail[keyRefName]['_id'] : undefined;
                if (!id)
                    continue;
                /** @type {?} */
                let mapField = this.detail[fieldName];
                if (mapField[recordKey] == id)
                    continue; //already populated for the same id
                refService.getDetail(id).subscribe(detail => {
                    if (Array.isArray(detail[fieldDef[5]])) {
                        keyArray = detail[fieldDef[5]];
                        mapField['keys'] = keyArray;
                        mapField[recordKey] = id; //record that keys is populated from this object
                        if (mapField['selection']) {
                            for (let k of keyArray) {
                                if (!(k in mapField['selection']))
                                    mapField['selection'][k] = "";
                            }
                        }
                    }
                }, this.onServiceError);
            }
        }
    }
    /**
     * @private
     * @param {?} arr1
     * @param {?} arr2
     * @return {?}
     */
    equalTwoSearchContextArrays(arr1, arr2) {
        if (!arr1)
            arr1 = [];
        if (!arr2)
            arr2 = [];
        if (arr1.length == 0 && arr2.length == 0)
            return true;
        //all object in array has format of {'field': 'value'} format
        /**
         * @param {?} a
         * @param {?} b
         * @return {?}
         */
        function compareObj(a, b) {
            /** @type {?} */
            let a_s = JSON.stringify(a);
            /** @type {?} */
            let b_s = JSON.stringify(b);
            if (a_s < b_s)
                return -1;
            if (a_s > b_s)
                return 1;
            return 0;
        }
        arr1 = arr1.sort(compareObj);
        arr2 = arr2.sort(compareObj);
        if (JSON.stringify(arr1) == JSON.stringify(arr2))
            return true;
        return false;
    }
    /**
     * @protected
     * @return {?}
     */
    processSearchContext() {
        this.moreSearchOpened = false;
        /** @type {?} */
        let d = this.detail;
        for (let s of this.stringFields) {
            d[s] = this.searchText;
        }
        /** @type {?} */
        let orSearchContext = [];
        /** @type {?} */
        let andSearchContext = [];
        for (let field in d) {
            if (typeof d[field] == 'string') {
                /** @type {?} */
                let o = {};
                o[field] = d[field];
                orSearchContext.push(o);
            }
        }
        this.searchMoreDetail = [];
        /** @type {?} */
        let d2 = this.deFormatDetail(d);
        for (let field in d2) {
            if (this.stringFields.indexOf(field) == -1) { //string fields already put to orSearchContext
                //string fields already put to orSearchContext
                /** @type {?} */
                let o = {};
                /** @type {?} */
                let valueToShow;
                o[field] = d2[field];
                if (this.multiSelectionFields.includes(field)) {
                    o[field] = { $in: d2[field] }; //use $in for or, and $all for and
                    //use $in for or, and $all for and
                    /** @type {?} */
                    let t = this.formatArrayMultiSelectionField(d2[field], this.enums[field]);
                    valueToShow = t.value;
                }
                else if (this.arrayFields.some(x => x[0] == field)) {
                    o[field] = { $in: d2[field] }; //use $in for or, and $all for and
                    valueToShow = d[field]['value'];
                }
                else if (this.dateFields.includes(field)) {
                    /** @type {?} */
                    let t = this.formatDateField(d2[field]);
                    valueToShow = t.value;
                }
                else if (this.referenceFields.includes(field)) {
                    valueToShow = valueToShow = d[field]['value'];
                }
                else {
                    valueToShow = d[field]; //take directoy from what we get 
                }
                this.searchMoreDetail.push([field, valueToShow]);
                andSearchContext.push(o);
            }
        }
        //Handle date range selection. These fields are not in d2, because field.date is undefined.
        for (let prop of this.dateFields) {
            /** @type {?} */
            let o = {};
            /** @type {?} */
            let valueToShow = "";
            o[prop] = {};
            if (typeof d[prop] !== 'object') { //not defined
                continue;
            }
            if (!d[prop]['from'] && !d[prop]['to']) { //not range
                continue;
            }
            if (d[prop]['from']) {
                o[prop]['from'] = this.deFormatDateField(d[prop]['from']);
                valueToShow += this.formatDateField(o[prop]['from']).value;
            }
            valueToShow += " ~ ";
            if (d[prop]['to']) {
                o[prop]['to'] = this.deFormatDateField(d[prop]['to']);
                valueToShow += this.formatDateField(o[prop]['to']).value;
            }
            this.searchMoreDetail.push([prop, valueToShow]);
            andSearchContext.push(o);
        }
        /** @type {?} */
        let searchContext = { '$and': [{ '$or': orSearchContext }, { '$and': andSearchContext }] };
        /* searchContext ={'$and', [{'$or', []},{'$and', []}]}
                */
        /** @type {?} */
        let context = this.getFromStorage("searchContext");
        if (context && context["$and"]) {
            /** @type {?} */
            let cachedOr;
            /** @type {?} */
            let cachedAnd;
            for (let sub of context["$and"]) {
                if ('$and' in sub)
                    cachedAnd = sub['$and'];
                else if ('$or' in sub)
                    cachedOr = sub['$or'];
            }
            if (this.equalTwoSearchContextArrays(cachedOr, orSearchContext)
                && this.equalTwoSearchContextArrays(cachedAnd, andSearchContext)) {
                return;
            }
        }
        if (orSearchContext.length == 0 && andSearchContext.length == 0)
            searchContext = null;
        this.putToStorage("searchContext", searchContext);
        this.putToStorage("searchText", this.searchText);
        this.putToStorage("page", 1); //start from 1st page
        this.putToStorage("searchMoreDetail", this.searchMoreDetail);
        this.putToStorage("detail", this.detail);
    }
    /**
     * @protected
     * @return {?}
     */
    searchList() {
        this.processSearchContext();
        //update the URL
        this.router.navigate(['.', {}], { relativeTo: this.route }); //start from 1st page
        this.putToStorage("page", 1); //start from 1st page
        this.populateList();
    }
    /**
     * @protected
     * @return {?}
     */
    loadUIFromCache() {
        //Now let's reload the search condition to UI
        this.searchText = this.getFromStorage("searchText");
        this.searchMoreDetail = this.getFromStorage("searchMoreDetail");
        /** @type {?} */
        let detail = this.getFromStorage("detail");
        if (detail)
            this.detail = detail;
    }
    /**
     * @protected
     * @return {?}
     */
    populateList() {
        //First let's handle page
        /** @type {?} */
        let new_page;
        /** @type {?} */
        let searchContext;
        /** @type {?} */
        let url_page = parseInt(this.route.snapshot.paramMap.get('page'));
        /** @type {?} */
        let cached_page = parseInt(this.getFromStorage("page"));
        if (cached_page) {
            new_page = cached_page;
            if (cached_page == 1)
                this.router.navigate(['.', {}], { relativeTo: this.route, }); //update the url
            else
                this.router.navigate(['.', { page: cached_page }], { relativeTo: this.route, }); //update the url
        }
        else if (url_page)
            new_page = url_page;
        else
            new_page = 1;
        searchContext = this.getFromStorage("searchContext");
        this.loadUIFromCache();
        this.service.getList(new_page, this.per_page, searchContext).subscribe(result => {
            this.list = result.items.map(x => this.formatDetail(x));
            this.page = result.page;
            this.per_page = result.per_page;
            this.total_count = result.total_count;
            this.total_pages = result.total_pages;
            this.populatePages();
            this.checkedItem =
                Array.apply(null, Array(this.list.length)).map(Boolean.prototype.valueOf, false);
            this.checkAll = false;
            if (this.refreshing) {
                this.refreshing = false;
                /** @type {?} */
                let snackBarConfig = {
                    content: "List refreshed"
                };
                /** @type {?} */
                let snackBar = new SnackBar(snackBarConfig);
                snackBar.show();
            }
            this.eventEmitter.emit(this.list);
        }, this.onServiceError);
        return this.eventEmitter;
    }
    /*UI operations handlers*/
    /**
     * @return {?}
     */
    onRefresh() {
        if (this.view == ViewType.LIST) {
            this.refreshing = true;
            this.populateList();
        }
        else if (this.view == ViewType.DETAIL) {
            this.refreshing = true;
            if (!this.id)
                this.id = this.route.snapshot.paramMap.get('id');
            if (this.id)
                this.populateDetail(this.id);
            else
                console.error("Routing error for detail view... no id...");
        }
    }
    /**
     * @return {?}
     */
    onCheckAllChange() {
        this.checkedItem =
            Array.apply(null, Array(this.list.length)).
                map(Boolean.prototype.valueOf, this.checkAll);
    }
    /**
     * @return {?}
     */
    isItemSelected() {
        return this.checkedItem.some((value) => { return value; });
    }
    /**
     * @return {?}
     */
    onDeleteSelected() {
        /** @type {?} */
        let deletedItem = [];
        this.checkedItem.forEach((value, index) => {
            if (value) {
                deletedItem.push(this.list[index]["_id"]);
            }
        });
        /** @type {?} */
        let modalConfig = {
            title: "Delete Confirmation",
            content: "Are you sure you want to delete selected items from the system?",
            //list of button text
            buttons: ['Delete', 'Cancel'],
            //list of button returns when clicked
            returns: [true, false],
            callBack: (result) => {
                if (result) {
                    this.service.deleteManyByIds(deletedItem).subscribe(result => {
                        /** @type {?} */
                        let snackBarConfig = {
                            content: this.ItemCamelName + " deleted"
                        };
                        /** @type {?} */
                        let snackBar = new SnackBar(snackBarConfig);
                        snackBar.show();
                        if (this.view != ViewType.LIST)
                            this.router.navigate(['../../list'], { relativeTo: this.route });
                        else {
                            /** @type {?} */
                            let len = this.checkedItem.length;
                            for (let i = 0; i < len; i++) {
                                /** @type {?} */
                                let idx = len - 1 - i;
                                /** @type {?} */
                                let value = this.checkedItem[idx];
                                if (value) {
                                    this.list.splice(idx, 1);
                                    this.checkedItem.splice(idx, 1);
                                    this.total_count -= 1;
                                }
                            }
                        }
                    }, this.onServiceError);
                }
            }
        };
        /** @type {?} */
        let modal = new Modal(modalConfig);
        modal.show();
    }
    /**
     * @param {?} id
     * @param {?} idx
     * @return {?}
     */
    onDelete(id, idx) {
        /** @type {?} */
        let modalConfig = {
            title: "Delete Confirmation",
            content: "Are you sure you want to delete this " + this.itemCamelName + " from the system?",
            //list of button text
            buttons: ['Delete', 'Cancel'],
            //list of button returns when clicked
            returns: [true, false],
            callBack: (result) => {
                if (result) {
                    this.service.deleteOne(id).subscribe(result => {
                        /** @type {?} */
                        let snackBarConfig = {
                            content: this.ItemCamelName + " deleted"
                        };
                        /** @type {?} */
                        let snackBar = new SnackBar(snackBarConfig);
                        snackBar.show();
                        if (this.view != ViewType.LIST)
                            this.router.navigate(['../../list'], { relativeTo: this.route });
                        else if (idx != null && this.list) {
                            this.list.splice(idx, 1);
                            this.checkedItem.splice(idx, 1);
                            this.total_count -= 1;
                        }
                    }, this.onServiceError);
                }
            }
        };
        /** @type {?} */
        let modal = new Modal(modalConfig);
        modal.show();
    }
    /**
     * @return {?}
     */
    onSubmit() {
        if (!this.extraFieldsLoad())
            return; //error from other non ngModel fields;
        this._detail = this.deFormatDetail(this.detail);
        if (this.id) {
            this.service.updateOne(this.id, this._detail).subscribe(result => {
                /** @type {?} */
                var snackBarConfig = {
                    content: this.ItemCamelName + " updated."
                };
                /** @type {?} */
                var snackBar = new SnackBar(snackBarConfig);
                snackBar.show();
                this.router.navigate(['../../detail', this.id], { relativeTo: this.route });
            }, this.onServiceError);
        }
        else {
            this.service.createOne(this._detail).subscribe(result => {
                /** @type {?} */
                let action = this.subEdit ? " added" : " created.";
                /** @type {?} */
                var snackBarConfig = {
                    content: this.ItemCamelName + action
                };
                /** @type {?} */
                var snackBar = new SnackBar(snackBarConfig);
                snackBar.show();
                this.id = result["_id"];
                this._detail = result;
                if (this.subEdit) {
                    this.done.emit(true);
                }
                else {
                    this.router.navigate(['../detail', this.id], { relativeTo: this.route });
                }
            }, this.onServiceError);
        }
    }
    /**
     * @return {?}
     */
    editCancel() {
        if (this.subEdit) {
            this.done.emit(false);
        }
        else {
            this.goBack();
        }
    }
    /**
     * @param {?} fn
     * @param {?} detail
     * @param {?} event
     * @return {?}
     */
    onDisplayRefClicked(fn, detail, event) {
        /** @type {?} */
        let ref = this.getRefFromField(fn);
        /** @type {?} */
        let d = detail;
        if (d && d['_id']) {
            if (this.list) {
                for (let item of this.list) {
                    if (item[fn] == d)
                        this.clickedId = item['_id'];
                }
            }
            this.router.navigate([ref, 'detail', d['_id']], { relativeTo: this.getParentActivatedRouter() });
        }
        if (event)
            event.stopPropagation();
    }
    /**
     * @param {?} id
     * @return {?}
     */
    onDetailLinkClicked(id) {
        this.clickedId = id;
        this.router.navigate([this.itemName, 'detail', id], { relativeTo: this.getParentActivatedRouter() });
    }
    /**
     * @protected
     * @param {?} fn
     * @return {?}
     */
    getRefFromField(fn) {
        return this.referenceFieldsMap[fn];
    }
    /**
     * @param {?} field
     * @return {?}
     */
    clearValueFromDetail(field) {
        if (!this.detail.hasOwnProperty(field))
            return;
        if (typeof this.detail[field] == 'undefined')
            return;
        if (typeof this.detail[field] == 'object') { //reference field or date
            if (this.multiSelectionFields.includes(field)) {
                this.detail[field] = this.clearFieldArrayMultiSelection(this.detail[field]);
            }
            else if (this.arrayFields.some(x => x[0] == field)) {
                this.detail[field] = this.clearFieldArray(this.detail[field]);
            }
            else if (this.mapFields.some(x => x[0] == field)) {
                this.detail[field] = this.clearFieldMap(this.detail[field]);
            }
            else if (this.dateFields.includes(field)) {
                this.detail[field] = this.clearFieldDate(this.detail[field]);
            }
            else if (this.referenceFields.includes(field)) {
                this.detail[field] = this.clearFieldReference(this.detail[field]);
            }
            //check if any info needs to change after clear certain values;
            this.extraInfoPopulate();
        }
        else {
            delete this.detail[field];
        }
    }
    /**
     * @param {?} field
     * @param {?} idx
     * @return {?}
     */
    clearValueFromArrayField(field, idx) {
        if (this.detail[field]['selection']) {
            this.detail[field]['selection'] = this.detail[field]['selection'].filter((x, i) => i != idx);
            //check if any info needs to change after clear certain values;
            this.extraInfoPopulate();
        }
    }
    /**
     * @param {?} field
     * @param {?} key
     * @return {?}
     */
    clearValueFromMapField(field, key) {
        if (this.detail[field]['selection']) {
            delete this.detail[field]['selection'][key];
            //check if any info needs to change after clear certain values;
            this.extraInfoPopulate();
        }
    }
    /**
     * @param {?} field
     * @param {?} key
     * @return {?}
     */
    clearValueFromMapKey(field, key) {
        if (this.detail[field]['selection']) {
            this.detail[field]['selection'][key] = undefined;
            //check if any info needs to change after clear certain values;
            this.extraInfoPopulate();
        }
    }
    /**
     * @param {?} field
     * @return {?}
     */
    checkValueDefinedFromDetail(field) {
        /** @type {?} */
        let d = this.detail;
        if (!d.hasOwnProperty(field))
            return false;
        if (typeof d[field] == 'undefined')
            return false;
        if (typeof this.detail[field] == 'number'
            || typeof d[field] == 'string'
            || typeof d[field] == 'boolean')
            return true;
        if (typeof d[field] == 'object') {
            if (this.multiSelectionFields.includes(field)) {
                return this.isDefinedFieldArrayMultiSelection(d[field]);
            }
            else if (this.arrayFields.some(x => x[0] == field)) {
                return this.isDefinedFieldArray(d[field]);
            }
            else if (this.mapFields.some(x => x[0] == field)) {
                return this.isDefinedFieldMap(d[field]);
            }
            else if (this.dateFields.includes(field)) {
                return this.isDefinedFieldDate(d[field]);
            }
            else if (this.referenceFields.includes(field)) {
                return this.isDefinedFieldReference(d[field]);
            }
        }
        return false;
    }
    /**
     * @param {?} field
     * @return {?}
     */
    clearValueFromDetailAndSearchList(field) {
        this.clearValueFromDetail(field);
        this.searchList();
    }
    /**
     * @param {?} fieldName
     * @return {?}
     */
    onAddArrayItem(fieldName) {
        if (this.arrayFields.some(x => x[0] == fieldName)) {
            if (this.detail[fieldName]['new']) { //where new added item is stored
                //where new added item is stored
                /** @type {?} */
                let item = this.detail[fieldName]['new'];
                this.detail[fieldName]['new'] = undefined; //clear it
                this.detail[fieldName]['selection'].push(item);
                /** @type {?} */
                let values = [];
                if (this.detail[fieldName]['value'])
                    values = this.detail[fieldName]['value'].split(' | ');
                values.push(item); //display value
                values = values.filter(x => !!x);
                this.detail[fieldName]['value'] = values.join(' | ');
                //see if related info needs to change after the change of this value
                this.extraInfoPopulate();
            }
        }
    }
    /**
     * @param {?} fieldName
     * @return {?}
     */
    onAddMapItem(fieldName) {
        if (this.mapFields.some(x => x[0] == fieldName)) {
            if (this.detail[fieldName]['new']) { //where new added item is stored
                //where new added item is stored
                /** @type {?} */
                let item = this.detail[fieldName]['new'];
                this.detail[fieldName]['new'] = undefined; //clear it
                this.detail[fieldName]['selection'][item] = undefined; //move to selection object
                //TODO: this.detail[fieldName]['value'] change
                //see if related info needs to change after the change of this value
                this.extraInfoPopulate();
            }
        }
    }
    /**
     * @param {?} fieldName
     * @return {?}
     */
    onRefSelect(fieldName) {
        if (!this.refSelectDirective) {
            console.warn("No reference directive for field: ", fieldName);
            return;
        }
        /** @type {?} */
        let viewContainerRef = this.refSelectDirective.viewContainerRef;
        viewContainerRef.clear();
        if (!this.selectComponents[fieldName]) {
            console.warn("No reference defined for field: ", fieldName);
            return;
        }
        /** @type {?} */
        let componentRef = this.selectComponents[fieldName]["componentRef"];
        if (!componentRef) {
            /** @type {?} */
            let comType = this.selectComponents[fieldName]["select-type"];
            if (!comType)
                console.warn("No component type found for reference field ", fieldName);
            /** @type {?} */
            let componentFactory = this.componentFactoryResolver.resolveComponentFactory(comType);
            componentRef = viewContainerRef.createComponent(componentFactory); //create and insert in one call
            this.selectComponents[fieldName]["componentRef"] = componentRef; //save it
        }
        else {
            viewContainerRef.insert(componentRef.hostView);
        }
        /** @type {?} */
        let componentInstance = (/** @type {?} */ (componentRef.instance));
        if (this.detail[fieldName]) {
            if (this.referenceFields.includes(fieldName)) {
                componentInstance.inputData = this.detail[fieldName]['_id'];
            }
        }
        componentInstance.setFocus();
        this.componentSubscription = componentInstance.done.subscribe((val) => {
            if (val) {
                this.componentSubscription.unsubscribe();
                viewContainerRef.detach(); //only detach. not destroy
            }
            /** @type {?} */
            let outputData = componentInstance.outputData;
            if (outputData) {
                switch (outputData.action) {
                    case "selected":
                        if (this.arrayFields.some(x => x[0] == fieldName)) {
                            this.detail[fieldName]['selection'].push(outputData.value);
                            /** @type {?} */
                            let values = [];
                            if (this.detail[fieldName]['value'])
                                values = this.detail[fieldName]['value'].split(' | ');
                            values.push(outputData.value.value); //display value
                            values = values.filter(x => !!x);
                            this.detail[fieldName]['value'] = values.join(' | ');
                        }
                        else if (this.referenceFields.includes(fieldName)) {
                            this.detail[fieldName] = outputData.value;
                        }
                        //trigger extraInfo populate, once reference changed.
                        this.extraInfoPopulate();
                        break;
                    case "view":
                        this.onRefShow(fieldName, "select", outputData.value); //value is _id
                        break;
                    default:
                        break;
                }
            }
        });
    }
    /**
     * @param {?} fieldName
     * @param {?} action
     * @param {?} id
     * @return {?}
     */
    onRefShow(fieldName, action, id) {
        if (!id && this.detail[fieldName])
            id = this.detail[fieldName]['_id'];
        if (!id) {
            console.error('Show reference but no id is given.');
            return;
        }
        /** @type {?} */
        let viewContainerRef = this.refSelectDirective.viewContainerRef;
        viewContainerRef.clear();
        /** @type {?} */
        let detailType = action + "-detail-type";
        //eg: select-detail-type, pop-detail-type
        /** @type {?} */
        let comType = this.selectComponents[fieldName][detailType];
        if (!comType) {
            console.error("No component type found for: %s", detailType);
            return;
        }
        /** @type {?} */
        let componentFactory = this.componentFactoryResolver.resolveComponentFactory(comType);
        /** @type {?} */
        let componentRef = viewContainerRef.createComponent(componentFactory);
        //create and insert in one call
        /** @type {?} */
        let componentInstance = (/** @type {?} */ (componentRef.instance));
        componentInstance.inputData = id;
        componentInstance.setFocus();
        componentInstance.done.subscribe((val) => {
            if (val) {
                componentInstance.done.unsubscribe();
                viewContainerRef.clear();
            }
            /** @type {?} */
            let outputData = componentInstance.outputData;
            if (outputData) {
                switch (outputData.action) {
                    case "selected":
                        if (this.arrayFields.some(x => x[0] == fieldName)) {
                            this.detail[fieldName]['selection'].push(outputData.value);
                            /** @type {?} */
                            let values = [];
                            if (this.detail[fieldName]['value'])
                                values = this.detail[fieldName]['value'].split(' | ');
                            values.push(outputData.value.value); //display value
                            values = values.filter(x => !!x);
                            this.detail[fieldName]['value'] = values.join(' | ');
                        }
                        else if (this.referenceFields.includes(fieldName)) {
                            this.detail[fieldName] = outputData.value;
                        }
                        //trigger extraInfo populate, once reference changed.
                        this.extraInfoPopulate();
                        break;
                    case "back":
                        this.onRefSelect(fieldName);
                        break;
                    default:
                        break;
                }
            }
        });
    }
    //ElementRef
    /**
     * @return {?}
     */
    setFocus() {
        if (this.focusEl)
            this.focusEl.nativeElement.focus();
    }
    /**
     * @return {?}
     */
    uiCloseModal() {
        this.outputData = null;
        this.done.emit(true);
    }
    /**
     * @return {?}
     */
    uiOnEscapeKey() {
        this.uiCloseModal();
    }
    /**
     * @param {?} num
     * @return {?}
     */
    selectItemSelected(num) {
        /** @type {?} */
        let detail = this.list[num];
        this.selectedId = detail['_id'];
        this.clickedId = detail['_id'];
        this.outputData = { action: "selected",
            value: { "_id": detail["_id"], "value": this.stringify(detail) },
            detail: detail
        };
        this.done.emit(true);
    }
    /**
     * @return {?}
     */
    detailSelSelected() {
        /** @type {?} */
        let detail = this.detail;
        this.outputData = { action: "selected",
            value: { "_id": detail["_id"], "value": this.stringify(detail) },
            detail: detail
        };
        this.done.emit(true);
    }
    /**
     * @param {?} num
     * @return {?}
     */
    selectViewDetail(num) {
        /** @type {?} */
        let detail = this.list[num];
        this.clickedId = detail['_id'];
        this.outputData = { action: "view",
            value: detail["_id"]
        };
        this.done.emit(true);
    }
    /**
     * @return {?}
     */
    detailSelBack() {
        this.outputData = { action: "back",
            value: null
        };
        this.done.emit(true);
    }
    /**
     * @return {?}
     */
    toggleMoreSearch() {
        this.moreSearchOpened = !this.moreSearchOpened;
    }
    /**
     * @return {?}
     */
    onSearchTextClear() {
        this.searchText = undefined;
        if (!this.moreSearchOpened)
            this.searchList();
    }
    /**
     * @return {?}
     */
    onSearchClear() {
        this.searchText = undefined;
        /** @type {?} */
        let detail = {};
        this.detail = this.formatDetail(detail);
        this.searchList();
    }
    /**
     * @protected
     * @return {?}
     */
    extraFieldsUnload() {
        if (this.textEditors) {
            this.textEditors.forEach(editor => {
                /** @type {?} */
                let fieldName = editor.name;
                /** @type {?} */
                let validatorObj = this.textEditorMap[fieldName];
                if (!validatorObj)
                    return;
                /** @type {?} */
                let content = this.detail[validatorObj.fieldName];
                if (content)
                    editor.setContent(content);
            });
        }
    }
    /**
     * @protected
     * @return {?}
     */
    extraFieldsLoad() {
        //to server
        /** @type {?} */
        let result = true;
        if (this.textEditors) {
            /** @type {?} */
            let array = this.textEditors.toArray();
            for (let editor of array) {
                /** @type {?} */
                let fieldName = editor.name;
                let [content, text] = editor.getContent();
                /** @type {?} */
                let validatorObj = this.textEditorMap[fieldName];
                if (!validatorObj)
                    continue;
                /** @type {?} */
                let fieldState = validatorObj.fieldState;
                fieldState.errors = {};
                if (!content) {
                    if (validatorObj.required) {
                        fieldState.errors.required = true;
                        fieldState.valid = false;
                        result = false;
                    }
                    continue;
                }
                if ('minlength' in validatorObj && text.length < validatorObj.minlength) {
                    fieldState.valid = false;
                    fieldState.errors.minlength = true;
                    result = false;
                    continue;
                }
                if ('maxlength' in validatorObj && text.length > validatorObj.maxlength) {
                    fieldState.valid = false;
                    fieldState.errors.maxlength = true;
                    result = false;
                    continue;
                }
                if ('validators' in validatorObj) {
                    /** @type {?} */
                    let error = validatorObj['validators'].validateValue(text);
                    if (error) {
                        fieldState.valid = false;
                        fieldState.errors = error;
                        result = false;
                        continue;
                    }
                }
                fieldState.valid = true;
                fieldState.errors = undefined;
                this.detail[validatorObj.fieldName] = content;
            }
        }
        return result;
    }
    /**
     * @param {?} editorName
     * @return {?}
     */
    onEdtiorPreview(editorName) {
        if (this.textEditors)
            this.textEditors.forEach((editor) => {
                if (editor.name == editorName)
                    editor.preview();
            });
    }
    /*Parent router related*/
    /**
     * @protected
     * @return {?}
     */
    getParentRouteItem() {
        /** @type {?} */
        let routeSnapshot = this.route.snapshot;
        /** @type {?} */
        let parentItem;
        do {
            if (routeSnapshot.data && routeSnapshot.data.mraLevel == 1) {
                parentItem = routeSnapshot.data.item;
                break;
            }
            routeSnapshot = routeSnapshot.parent;
        } while (routeSnapshot);
        return parentItem;
    }
    /**
     * @protected
     * @return {?}
     */
    getParentRouteItemId() {
        /** @type {?} */
        let routeSnapshot = this.route.snapshot;
        /** @type {?} */
        let parentItemId;
        do {
            if (routeSnapshot.data && routeSnapshot.data.mraLevel == 1 && ('id' in routeSnapshot.params)) {
                parentItemId = routeSnapshot.params.id;
                break;
            }
            routeSnapshot = routeSnapshot.parent;
        } while (routeSnapshot);
        return parentItemId;
    }
    /**
     * @protected
     * @return {?}
     */
    getParentRouteRefField() {
        /** @type {?} */
        let mp = this.referenceFieldsMap;
        for (let prop in mp) {
            if (mp.hasOwnProperty(prop) && mp[prop] == this.parentItem) {
                return prop;
            }
        }
    }
    /**
     * @protected
     * @return {?}
     */
    getParentActivatedRouter() {
        /** @type {?} */
        let route = this.route;
        do {
            /** @type {?} */
            let data = route.snapshot.data;
            //all route inside the mra system will have mraLevel data item
            if (!data.mraLevel)
                return route;
            route = route.parent;
        } while (route);
        return this.route.root;
    }
    /*Sub detail show flag*/
    /**
     * @param {?} i
     * @return {?}
     */
    toggleCheckedItem(i) {
        this.checkedItem[i] = !this.checkedItem[i];
    }
    /**
     * @return {?}
     */
    onAdd() {
        this.isAdding = true;
    }
    /**
     * @return {?}
     */
    toggleAdd() {
        this.isAdding = !this.isAdding;
    }
    /**
     * @param {?} result
     * @return {?}
     */
    onAddDone(result) {
        this.isAdding = false;
        if (result) { //add successful. Re-populate the current list
            if (this.view == ViewType.LIST) {
                this.populateList();
            }
        }
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    onDateSelectionToggle(fn) {
        this.detail[fn]['pop'] = !this.detail[fn]['pop'];
    }
    /**
     * @param {?} fn
     * @param {?} date
     * @return {?}
     */
    onDateSelection(fn, date) {
        if (!this.detail[fn]['from'] && !this.detail[fn]['to']) {
            this.detail[fn]['from'] = date;
        }
        else if (this.detail[fn]['from'] && !this.detail[fn]['to'] && date.after(this.detail[fn]['from'])) {
            this.detail[fn]['to'] = date;
            this.detail[fn]['pop'] = false; //Finished. hide the selection 
        }
        else {
            this.detail[fn]['to'] = null;
            this.detail[fn]['from'] = date;
        }
    }
    /**
     * @param {?} fn
     * @param {?} date
     * @return {?}
     */
    isHovered(fn, date) {
        return this.detail[fn]['from'] && !this.detail[fn]['to'] && this.hoveredDate && date.after(this.detail[fn]['from']) && date.before(this.hoveredDate);
    }
    /**
     * @param {?} fn
     * @param {?} date
     * @return {?}
     */
    isInside(fn, date) {
        return date.after(this.detail[fn]['from']) && date.before(this.detail[fn]['to']);
    }
    /**
     * @param {?} fn
     * @param {?} date
     * @return {?}
     */
    isRange(fn, date) {
        return date.equals(this.detail[fn]['from']) || date.equals(this.detail[fn]['to']) || this.isInside(fn, date) || this.isHovered(fn, date);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MinNumber {
    /**
     * @param {?} control
     * @return {?}
     */
    validate(control) {
        /** @type {?} */
        let num = control.value;
        /** @type {?} */
        let minnum = parseFloat(this.minnumber);
        if (isNaN(minnum))
            return null; //only compare when max is a number
        //only compare when inputs are numbers
        if (typeof num == 'number' && num < minnum)
            return { 'minnumber': "must be no less than " + minnum };
        return null;
    }
}
MinNumber.decorators = [
    { type: Directive, args: [{
                selector: '[minnumber]',
                providers: [{ provide: NG_VALIDATORS, useExisting: MinNumber, multi: true }]
            },] }
];
MinNumber.propDecorators = {
    minnumber: [{ type: Input, args: ['minnumber',] }]
};
class MaxNumber {
    /**
     * @param {?} control
     * @return {?}
     */
    validate(control) {
        /** @type {?} */
        let num = control.value;
        /** @type {?} */
        let maxnum = parseFloat(this.maxnumber);
        if (isNaN(maxnum))
            return null; //only compare when max is a number
        //only compare when inputs are numbers
        if (typeof num == 'number' && num > maxnum)
            return { 'maxnumber': "must be no greater than " + maxnum };
        return null;
    }
}
MaxNumber.decorators = [
    { type: Directive, args: [{
                selector: '[maxnumber]',
                providers: [{ provide: NG_VALIDATORS, useExisting: MaxNumber, multi: true }]
            },] }
];
MaxNumber.propDecorators = {
    maxnumber: [{ type: Input, args: ['maxnumber',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var fullscreenCss = `

.editorhide {
    display: none;
}
.editorfullscreen {
    display: block;
    position: fixed; 
    left: 0;
    top: 0;
    width: 100%;
    height: 100%; 
    overflow: auto; 
    z-index: 1050;
    background-color: #fff;
}

.editor-action-buttons {
    width: 100%;
    float:right; 
    text-align: right;
    margin-bottom: 1.25rem;
    margin-top: 2.5rem;
}
.editor-action-buttons .btn {
    display: inline-block;
    margin-left: 2.5rem;
}

`;
/** @type {?} */
var fullscreenHtml = `
<div class="editorfullscreen" id="mraeditorfullscreenDiv">

<div class="container">
  <div class="row">
    <div class="col">
      <div class="editor-action-buttons">
            <button id="mraeditorfullscreenClose" class="btn btn-outline-success">Close</button>
      </div>
    </div>
  </div>

  <div class="row">
    <div class="col">
        <div class="card">
            <div class="card-body" id="mrafullscreenHtml"></div>
        </div>
    </div>
  </div>
</div>

</div>
`;
/** @type {?} */
var summerNoteConfig = {
    minHeight: 200,
    focus: false,
    airMode: false,
    //fontNames: ['Roboto', 'Calibri', 'Times New Roman', 'Arial'],
    //fontNamesIgnoreCheck: ['Roboto', 'Calibri'],
    dialogsInBody: true,
    dialogsFade: true,
    disableDragAndDrop: false,
    toolbar: [
        // [groupName, [list of button]]
        ['font', ['style', 'fontname', 'fontsize', 'color']],
        ['style', ['bold', 'italic', 'underline']],
        //['font', [ 'superscript', 'subscript','clear']],
        ['paragraph', ['ul', 'ol', 'paragraph']],
        ['insert', ['table', 'picture', 'link', 'video']],
        //['misc', ['undo', 'redo', 'print', 'help', 'fullscreen']]
        ['misc', ['undo', 'redo', 'fullscreen']]
    ],
};
class MraRichTextSelectDirective {
    /**
     * @param {?} el
     * @param {?} render
     */
    constructor(el, render) {
        this.el = el;
        this.render = render;
        this.id = Date.now();
        //<!-- Create the editor container -->
        /** @type {?} */
        let html = `
            <div id="richtext` + this.id + `">
            </div>
            <div id="fullscreen` + this.id + `"></div>'
            `;
        if (!$('#mraeditorfullscreenCss').length) {
            $("<style type='text/css' id='mraeditorfullscreenCss'>" + fullscreenCss + "</style>").appendTo("head");
        }
        this.render.setProperty(this.el.nativeElement, 'innerHTML', html);
        setTimeout(() => {
            if (this.content)
                $("#richtext" + this.id).html(this.content);
            $("#richtext" + this.id).summernote(summerNoteConfig);
        }, 1);
    }
    /**
     * @param {?} content
     * @return {?}
     */
    setContent(content) {
        this.content = content;
        if (this.content) {
            $("#richtext" + this.id).each(function (index) {
                $(this).summernote('destroy');
            });
            $("#richtext" + this.id).html(this.content);
            $("#richtext" + this.id).summernote(summerNoteConfig);
        }
    }
    /**
     * @return {?}
     */
    getContent() {
        /** @type {?} */
        let html = $("#richtext" + this.id).summernote('code');
        /** @type {?} */
        let text = $("<div>" + html + "</div>").text();
        return [html, text];
    }
    /**
     * @return {?}
     */
    preview() {
        if (!$('#mraeditorfullscreenDiv').length) {
            $("#fullscreen" + this.id).append(fullscreenHtml);
        }
        $("#mraeditorfullscreenClose").click(function () {
            $('#mraeditorfullscreenDiv').remove();
        });
        let [html, text] = this.getContent();
        $("#mrafullscreenHtml").html(html);
    }
}
MraRichTextSelectDirective.decorators = [
    { type: Directive, args: [{
                selector: '[mra-richtext-select]',
            },] }
];
/** @nocollapse */
MraRichTextSelectDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
MraRichTextSelectDirective.propDecorators = {
    name: [{ type: Input, args: ['mra-richtext-select',] }]
};
class MraRichTextShowDirective {
    /**
     * @param {?} el
     * @param {?} render
     */
    constructor(el, render) {
        this.el = el;
        this.render = render;
    }
    /**
     * @param {?} content
     * @return {?}
     */
    setContent(content) {
        /** @type {?} */
        let id = Date.now();
        /** @type {?} */
        var displayHtml = `
            <div class="card">
                <div class="card-body" id="mraeditordisplay` + id + `"></div>
            </div>
        `;
        this.render.setProperty(this.el.nativeElement, 'innerHTML', displayHtml);
        $("#mraeditordisplay" + id).html(content);
    }
}
MraRichTextShowDirective.decorators = [
    { type: Directive, args: [{
                selector: '[mra-richtext-show]',
            },] }
];
/** @nocollapse */
MraRichTextShowDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
MraRichTextShowDirective.propDecorators = {
    name: [{ type: Input, args: ['mra-richtext-show',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MraModule {
}
MraModule.decorators = [
    { type: NgModule, args: [{
                imports: [],
                declarations: [
                    MinNumber,
                    MaxNumber,
                    MraRichTextSelectDirective,
                    MraRichTextShowDirective
                ],
                exports: [
                    MinNumber,
                    MaxNumber,
                    MraRichTextSelectDirective,
                    MraRichTextShowDirective
                ],
                providers: [
                    MraCommonService
                ],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var dateStructureToString = function (date, fmt) {
    /** @type {?} */
    let d;
    /** @type {?} */
    let M;
    /** @type {?} */
    let yyyy;
    /** @type {?} */
    let value;
    if (!date)
        return ""; //undefined
    d = date.day;
    M = date.month;
    yyyy = date.year;
    if (typeof d !== 'number' || typeof M !== 'number' || typeof yyyy !== 'number')
        return ""; //undefined
    //undefined
    /** @type {?} */
    let yy = yyyy.toString().slice(2);
    /** @type {?} */
    let dd = d < 10 ? '0' + d : d.toString();
    /** @type {?} */
    let MM = M < 10 ? '0' + M : M.toString();
    value = fmt.replace(/yyyy/ig, yyyy.toString()).
        replace(/yy/ig, yy.toString()).
        replace(/MM/g, MM.toString()).
        replace(/dd/ig, dd.toString());
    return value;
};
/** @type {?} */
var stringToDateStructure = function (value, fmt) {
    /** @type {?} */
    let date;
    /** @type {?} */
    let result = [];
    if (value.length != fmt.length)
        return date; //not ready
    //not ready
    /** @type {?} */
    let regexes = [{ re: /yyyy/i, len: 4 }, { re: /yy/i, len: 2 }, { re: /MM/, len: 2 }, { re: /dd/i, len: 2 }];
    for (let reg of regexes) {
        /** @type {?} */
        let p = fmt.search(reg.re);
        //find position in format
        /** @type {?} */
        let v;
        if (p != -1)
            v = parseInt(value.slice(p, p + reg.len));
        else
            v = NaN;
        result.push(v);
    }
    let [yyyy, yy, M, d] = result;
    if ((isNaN(yyyy) && isNaN(yy)) || isNaN(M) || isNaN(d))
        return date; //undefined
    return { day: d, month: M, year: yyyy ? yyyy : 2000 + yy };
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const COMPONENT_CACHE_DURATION = 30 * 1000;
class MraRouteReuseStrategy {
    constructor() {
        this.detachedRouteHandles = {}; //key is url, and value is at [handle, timestamp] format
        //key is url, and value is at [handle, timestamp] format
        this.pageYOffset = {};
        this.editItems = {};
        this.isAuth = false;
    }
    /* Start: The following should use the authService. But let's decouple dependency now */
    /**
     * @private
     * @return {?}
     */
    isAuthorized() {
        //Refer to AuthenticationService for this function.
        /** @type {?} */
        const authRecord = JSON.parse(localStorage.getItem('mdds-auth-record'));
        if (authRecord && authRecord.accessToken) {
            return true;
        }
        return false;
    }
    /**
     * @private
     * @return {?}
     */
    getLogoutTime() {
        /** @type {?} */
        const authRecord = JSON.parse(localStorage.getItem('mdds-auth-record'));
        if (authRecord) {
            return authRecord.logoutTs;
        }
        return 0;
    }
    /* End */
    /**
     * @private
     * @return {?}
     */
    isLogoutReload() {
        if (this.isAuthorized()) {
            return false;
        }
        /** @type {?} */
        const currentTs = Date.now();
        /** @type {?} */
        const logoutTs = this.getLogoutTime();
        if (currentTs - logoutTs < 1000) {
            return true;
        }
        return false;
    }
    /**
     * @private
     * @return {?}
     */
    checkAuthentication() {
        /** @type {?} */
        const auth = this.isAuth;
        this.isAuth = this.isAuthorized();
        if (this.isAuth != auth) {
            // authentication status changed. Not attach;
            this.detachedRouteHandles = {}; // empty the map
        }
    }
    /**
     * Determines if this route (and its subtree) should be detached to be reused later
     * @param {?} route
     * @return {?}
     */
    shouldDetach(route) {
        if (route.routeConfig && route.routeConfig.path === 'list') {
            //save current scroll position
            /** @type {?} */
            let key = route['_routerState'].url;
            this.pageYOffset[key] = window.pageYOffset;
        }
        return route.routeConfig.path === 'list';
    }
    /**
     * Stores the detached route
     * @param {?} route
     * @param {?} handle
     * @return {?}
     */
    store(route, handle) {
        /** @type {?} */
        const date = new Date();
        /** @type {?} */
        const key = route['_routerState'].url;
        if (!handle)
            return;
        this.detachedRouteHandles[key] = [handle, date.getTime()];
    }
    /**
     * Determines if this route (and its subtree) should be reattached
     * @param {?} route
     * @return {?}
     */
    shouldAttach(route) {
        this.checkAuthentication();
        /** @type {?} */
        let date = new Date();
        /** @type {?} */
        let key = route['_routerState'].url;
        if (route.routeConfig && (route.routeConfig.path === 'new' || route.routeConfig.path === 'edit/:id')) {
            if (route.data && route.data.item) {
                this.editItems[route.data.item] = true;
            }
        }
        if (!route.routeConfig || route.routeConfig.path !== 'list') {
            return false;
        }
        if (!this.detachedRouteHandles[key]) {
            return false;
        }
        if (date.getTime() - this.detachedRouteHandles[key][1] > COMPONENT_CACHE_DURATION)
            return false;
        return true;
    }
    /**
     * Retrieves the previously stored route
     * @param {?} route
     * @return {?}
     */
    retrieve(route) {
        /** @type {?} */
        let date = new Date();
        /** @type {?} */
        let key = route['_routerState'].url;
        if (!route.routeConfig || route.routeConfig.path !== 'list')
            return null;
        if (route.data.item && (route.data.item in this.editItems)) {
            delete this.editItems[route.data.item];
            delete this.detachedRouteHandles[key];
            return null;
        }
        if (!this.detachedRouteHandles[key])
            return null;
        if (date.getTime() - this.detachedRouteHandles[key][1] > COMPONENT_CACHE_DURATION)
            return null;
        /** @type {?} */
        let yOffset = this.pageYOffset[key];
        setTimeout(function () {
            console.log("==retrieve: ", key, yOffset);
            window.scrollTo(0, yOffset);
        }, 20); //scroll to saved position
        return this.detachedRouteHandles[key][0];
    }
    /**
     * Determines if a route should be reused
     * @param {?} future
     * @param {?} curr
     * @return {?}
     */
    shouldReuseRoute(future, curr) {
        // Below is the default implementation;
        if (this.isLogoutReload()) {
            return false; // authentication status changed. Don't reuse.
        }
        return future.routeConfig === curr.routeConfig;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { ViewType, BaseComponent, ServiceError, BaseService, MraCommonService, MraModule, MaxNumber, MinNumber, MraRichTextSelectDirective, MraRichTextShowDirective, ErrorToastConfig, ErrorToast, ModalConfig, Modal, SnackBarConfig, SnackBar, stringToDateStructure, dateStructureToString, MraRouteReuseStrategy };

//# sourceMappingURL=mean-rest-angular.js.map